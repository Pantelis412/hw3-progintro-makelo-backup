# NEWTON FRACTAL
# Αυτό είναι το μέρος 2 της εργασίας #3.
    Στην εργασία αυτή κληθήκαμε να υλοποιήσουμε την διαδικασία εύρεσης ριζών Newton-Raphson, όμως για complex αριθμούς (z = a + bi). Ξεκίνησαμε για αρχή την main με (int argc, char *argv[]) για να δεχτούμε το input από το stdin. Ύστερα ανοίξαμε με fopen τον φάκελο για read only "r" και ξεκινήσαμε με fscanf να διαβάζουμε τα στοιχεία του φακέλου και να τα αποθηκεύουμε σε μεταβλητές. Συγκεκριμένα, φτιάξαμε μια μεταβλητή για τον βαθμό του πολυωνύμου, ένα πίνακα για τους συντελεστές, μία struct που περιείχε δύο τύπους ώστε να διαβάσουμε σε δύο διαφορετικές μεταβλήτες το ελάχιστο και το μέγιστο στους πραγματικούς και μιγαδικούς αριθμούς καί μία μεταβλητή για το βήμα της συνάρτησης. Για να ακολουθήσουμε τις διευκρινήσεις της εκφώνησης, δημιουργήσαμε μία εμφωλευμένη for επανάληψη, καθώς τα αποτελέσματα που εκτυπόνωνται πρέπει να έχουν μορφή δισδιάστατου πίνακα. Επίσης, αρχικοποιήσαμε και δύο μεταβλητές για να μετράμε τις επαναλήψεις της Newton-Raphson και των διαφορετικών αριθμών για τους οποίους γίνεται αυτή. Έτσι, φτιάξαμε μια (εμφωλευμένη) struct που να αποθηκεύει τους νέους αριθμούς και τους παλιούς αριθμούς στην Newton-Raphson. Μέσα στην do...while που γίνεται η μέθοδος, αναβαθμίζουμε την "παλιά" μεταβλήτη και στο real μέρος και στο imaginary της και σπεύδουμε να βρουμε την καινούργια, αφού ελέγξουμε ότι η παράγωγος της συνάρτησης έιναι διάφορη του μηδενός αλλιώς κάνουμε break από την επανάληψη και τυπώνουμε nan. Τις καινούργιες μεταβλητές τις βρίσκουμε αφαιρώντας από τις παλιές την διαίρεση της συνάρτησης προς την παράγωγο της για τους παλιούς αριθμούς. Το δύσκολο κομμάτι της άσκησης ήταν ο διαχωρισμός των πραγματικών και μιγαδικών μερών των συναρτήσεων. Για την κάλυψη αυτού, εφόσον από τις προδιαγραφές απαγορευόταν η χρήση της βιβλιοθήκης <complex.h>, χρειάστηκε να φτιάξουμε δικό μας header file και .c αρχείο για αυτήν και να το κάνουμε #include "filename" στο βασικό αρχείο μας, όπου στο header αρχικοποιήσαμε τις συναρτήσεις που θα χρησιμοποιήσουμε και στο αρχείο c την υλοποίηση τους και το τι επιστρέφουν. Συγκεκριμένα, δημιουργήσαμε τέσσερις συναρτήσεις που δεχόντουσαν τα ίδια ορίσματα και επιστρέφουν, όπως παραχωρήθηκαν και στην εκφώνηση της άσκησης, τα πραγματικά και αντίστοιχα μιγαδικά μέρη των πράξεων μεταξύ complex αριθμών. Μετέπειτα, ορίσαμε τέσσερις συναρτήσεις ίδιου τύπου και εισόδου όπου υλοποιούνται οι πράξεις των συναρτήσεων και των παραγώγων και οι οποίες επιστρέφουν αντίστοιχα, ως συνήθως, τα πραγματικά και μιγαδικά μέρη της εξίσωσης. Οφείλουμε να πούμε ότι αυτό το σημείο φάνηκε να είναι το πιο δύσφορο για εμάς, παρότι ο κώδικας και στις τέσσερις συναρτήσεις είναι πανομοιότυπος με ελάχιστες διαφορές. Συγκεκριμένα, οι συναρτήσεις της παραγώγου χρησιμοποιούν έναν νέο πίνακα με τους συντελεστές του προηγούμενου επί τον βαθμό της ταυτότητας που ακολουθούσε ο συντελεστής, έχουν μειωμένο βαθμό κατά ένα και χωρίς το τελευταίο στοιχείο (συντελεστή Α0) και επιπλέον, στην περίπτωση των συναρτήσεων για τους μιγαδικούς, ο συντελεστής Α0 δεν υπολογίζεται καθώς αυτός είναι πάντα πραγματικός αριθμός. Μέσα στις συναρτήσεις αυτές, αρχικοποιήσαμε ένα sum που βρίσκει το σύνολο, αναλόγως την συνάρτηση, των πραγματικών ή μιγαδικών αριθμών της προκείμενης συνάρτησης, μία μεταβλητή που κάθε επανάληψη ελαττώνει τον βαθμό του πολυωνύμου για την εύρεση της επόμενης ταυτότητας και δύο μεταβλητές τύπου struct complex, μία που λειτουργεί ως temp και μία που αποθηκεύει τα αποτελέσματα. Για αυτό η temp μεταβλητή παίρνει στην αρχή την τιμή 0, όχι ότι μετράει ιδιαίτερα, ενώ η άλλη παίρνει ως τιμή την "παλιά" μεταβλητή (όπως αναφέρθηκε πιο πάνω). Ύστερα εισερχόμαστε μια for loop η οποία λειτουργεί για ταυτότητες ν >= 2, καθώς αυτές έχουν πράξεις μεταξύ complex αριθμών. Μέσα στην επανάληψη, οι temp μεταβλητές επαναφέρουν τα πραγματικά και μιγαδικά κομμάτια του πολλαπλασιασμού, όπως αυτά ορίστηκαν στο αρχείο complexlib.c - .h και αυτά αναθέτονται στην άλλη complex μεταβλητή. Να σημειωθεί ότι η temp μεταβλητή και στις δύο περιπτώσεις δέχεται το πραγματικό και το μιγαδικό κομμάτι της άλλης μεταβλητής και αντίστοιχα της "παλιάς" μεταβλητής και γυρνάει ανάλογο αποτέλεσμα. Τέλος, το πραγματικό και μιγαδικό μέρος κάθε ταυτότητας πολλαπλασιάζεται με τον συντελεστή της και ύστερα, ανάλογα την συνάρτηση, προστίθεται στο sum. Όταν κάθε συνάρτηση τελείωσει και επιστρέψει τα sum της, αυτά τοποθετούνται ως ορίσματα στην συνάρτηση για διαίρεση complex αριθμών δύο φορές, μία για την επιστροφή πραγματικού και την άλλη για επιστροφή μιγαδικού. Όταν η απόλυτη τιμή της διαφοράς μεταξύ της νέας και παλιάς μεταβλητής είναι μικρότερη από 10^-6 και το counter των επαναλήψεων δεν έχει ξεπεράσει τα χίλια, τότε το πρόγραμμα εμφανίζει, μετά απο κάποιες συνθήκες για τα πρόσημα τις ρίζες. Στην περίπτωση που το counter ξεπεράσει πρώτο τις 1000 επαναλήψεις, τότε τυπώνεται η λέξη incomplete. Μετά και από ένα απλό printf("\n"); για την ανάθεση νέας γραμμής και free πινακών καθώς και το fclose του φακέλου, έχουμε μια πλήρης functioning μέθοδο Newton-Raphson για complex αριθμούς.

# VISUALIZATION
# Αυτό είναι το μέρος 2.1 της εργασίας #3.
    Έχωντας την βάση χτισμένη απο το προηγούμενο μέρος της εργασίας, έσπευσα, σε περίπτωση που επιλεγεί από τον user, να οπτικοποιήσω την Newton-Raphson με το input που μας παραδίδεται. Ευτυχώς για εμάς, η εργασία #2 παρείχε ένα intro στην διαχείριση αρχείων .bmp, επομένως βρεθήκαμε να είμαστε πιο εξικοιωμένοι με το ερώτημα της άσκησης. Αρχικά ξεκινήσαμε, κάνωντας αποδεκτό στο argc και την τιμή 4 καθώς τόσα είναι τα ορίσματα του stdin σε αυτό το μέρος της εργασίας. Μετά, βρήκαμε το πλάτος και το μήκος του δισδιάστατου πίνακα που εμφανίζουμε στο Newton-Fractal και το χρησιμοποιούμε για να ορίσουμε έναν τρισδιάστατο πίνακα pixel_array[height of the pixels][width of the pixels][bytes of each pixel], του οποίου αρχικοποιούμε όλα του τα στοιχεία με 0. Ύστερα, δεσμεύουμε μνήμη για έναν δισδιάστατο πίνακα colors[root number][byte color] ώπου τον γεμίζουμε χειροκίνητα με χρώματα που θα αναθετιθούν στον pixel_array. Έπειτα, αρχικοποιούμε ένα πίνακα μήκους 2 * degree ώπου κάθε δύο κελιά αντιστοιχούν στο πραγματικό και μιγαδικό μέρος μιας ρίζας αντίστοιχα και ένα counter που θα μετράει το πλήθος των ριζών. Μετέπειτα, γυρνάμε το width και το height σε μηδέν πριν την εμφωλευμένη for και μέσα στην πρώτη for αυξάνουμε το height και στην δεύτερη το width ώστε να ταιριάζει με τον δισδιάστατο πίνακα αποτελεσμάτων. Αν το αποτέλεσμα που τυπώνεται είναι nan τότε το pixel_array εκείνου του width και height παίρνει το χρώμα μαύρο. Ανάλογα άμα τυπωθεί το incomplete και πάλι δεν βρεθεί ρίζα, τότε το pixel_array εκείνου του height και width παίρνει το χρώμα άσπρο. Στην περίπτωση που βρεθεί ρίζα, το πρόβλημα περιπλέκεται καθώς εισερχόμαστε σε μία συνάρτηση η οποία είναι σχεδιασμένη να αναθέσει χρώματα στον pixel_array αναλόγως την ρίζα. Κατά την είσοδο μέσα στην συνάρτηση, παρατηρείται ότι πολλαπλασιάζουμε τις ρίζες με το 100 ώστε να φέρουμε τα δύο ψηφία μετά την υποδιαστολή μπροστά της. Αυτό συνέβη επειδή μετά από αρκετό debugging, παρατηρήσαμε ότι παρότι οι ρίζες μπορεί να είναι ίδιες στα πρώτα δύο ψηφία μετά την υποδιαστολή, επειδή απαιτείται οι ρίζες να συγκλίνουν μόνο μέχρι το 10^-6, τότε ψηφία μετά το 6ο δεξιά της υποδιαστολής μπορεί να είναι διαφορετικά από της άλλες ρίζες που έχουν βρεθεί, επομένως πολλαπλασιάζουμε τις ρίζες επί εκατό και συγκρίνουμε μόνο το ακέραιο μέρος των ριζών, ώστε να αποφύγουμε τέτοιων ειδών λάθη. Πέρα από αυτό, χρησιμοποιούμε ένα κολπάκι με την διεύθυνση του counter των ριζών, το οποίο μας βοηθάει να αλλάξουμε την τιμή του μέσα στην συνάρτηση οριστικά, χωρίς δηλαδή να χάνει την τιμή της όταν επιστρέφει η συνάρτηση και βάζουμε τα ακέραια μέρη των πολλαπλασιασμένων roots στον πίνακα roots, ένα κελί για το κάθε μέρος, και εισέρχουμε το πρώτο χρώμα του colors στο pixel_array. Στην επόμενη είσοδο στην συνάρτηση, που το counter των ριζών θα είναι αυξημένο και η πρώτη συνθήκη θα είναι πάντα ψευδής, το πρόγραμμα μπαίνει σε ένα for loop το οποίο αυξάνεται ανά δύο, καθώς το root αλλάζει ανά δύο θέσεις και ελέγχεται αν το ακέραιο μέρος των ριζών είναι ίσο με το roots[i] και το roots[i + 1] αντίστοιχα, το πρώτο για το πραγματικό μέρος και το δεύτερο για το μιγαδικό και αν η συνθήκη ισχύει, τότε αναθέτεται στο pixel_array to colors που αντιστοιχεί στον αριθμό της ρίζας, που θα είναι το μισό του i το οποίο αυξάνεται ανά δύο, επομένως colors[i]. Στην περίπτωση που η ρίζα που έχει εισέλθει είναι καινούργια, δηλαδή το pixel_array είναι όπως αρχικοποιήθηκε στο 0, τότε αυξάνουμε τον αριθμό των ριζών, προσθέτουμε την ρίζα στον πίνακα roots και βάζουμε στον πίνακα pixel_array το colors της καινούργιας ρίζας. Αφού το εμφωλευμένο for τελειώσει ελέγχουμε αν το argc είναι ίσο με 4 και άμα είναι, χρησιμοποιούμε την fopen ώστε να ανοίξουμε το αρχείο για write με "w" και ξεκινάμε δεσμεύοντας μνήμη για το header του bmp. Για αυτό δημιουργούμε μία struct με όλα τα στοιχεία που έχει μέσα το συνηθισμένο header ενός bmp (εδώ αναδεικνύεται πολύ η εξάσκηση που είχαμε με την εργασία 2) και αρχίζουμε να του βάζουμε τιμές. Το περίεργο είναι στο width και στο height ώπου άμα οι τιμές τους ξεπέρναγαν το 255, το output.bmp έβγαινε damaged, επομένως μετά από αρκετό search, βρήκαμε ένα τρόπο για τοποθετήσουμε τα height και width στον πίνακα, όπου πέρναμε τα πρώτα 8 bit και τα βάζαμε στην πρώτη θέση τους, μετά μεταφερόμασταν 8 bit και βάζαμε τα bit 8 έως 16, μετά 16 έως 24 και τέλος 24 μέχρι 32, που είναι όσα bit έχει το height και το width αφού έχουν οριστεί στην struct ως uint32_t. Επίσης, υπολογίζουμε το padding της εικόνας, καθώς κάθε γραμμή πρέπει να έχει αρκετά bytes ωστέ να είναι πολλαπλάσια του 4, δηλαδή άμα το width ήταν 1 * 3 που είναι τα bytes του κάθε pixel τότε θα έλειπε ένα byte από την σειρά, που ονομάζεται padding. Αφού υπολογίσουμε το padding, τότε φτιάχνουμε τα bytes των pixel και τα bytes όλου του bmp ώστε να φαίνονται σωστά στο δεκαεξαδικό σύστημα του header. Μετά, αρχικοποιούμε έναν μονοδιαστάτο πίνακα final και ένα counter του, ο οποίος θα πάρει όλα τα στοιχεία του pixel_array μαζί με το padding, ξεκινώντας βέβαια από το height-1 μέχρι το 0, αφού στα bmp η θέση [0,0] βρίσκεται κάτω αριστερά αντί για πάνω αριστέρα και αυξάνεται ανάποδα από το κανονικό. Τέλος, κάνουμε δύο fwrite, ένα για το header και ένα για το final (pixel_array + padding) και μετά από κάποια free και ένα fclose....τότε σημάνεται το τέλος της εργασίας και του εξαμήνου!
